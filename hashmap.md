# hashMap
## hashMap得扩容机制
+ 1.7 还是通过是循环遍历去转移
+ 1.8  以后会使使用规律去扩容
+ key 是null的话，是存在第一个位置的
## 1.8的扩容逻辑
1.  new 一个table
2. 尾插法
3. 首先如果是第一次插入就会 new一个初始大小的table -》 然后new一个新的node -》 根据hashcode从计算索引，
插入-》如果当前位置为空就将node放到到table里面-》 如果这个位置有元素，就会从头开遍历（比较，计数）-》
直到最后一个元素，添加到尾部 -》 判断当前链表是否是达到8 -》 转为红黑树
4. 问题：链表长度大于8一定会转化成红黑树吗 
     + 答案是：不会，如果当前的table长度小于64时，hashmap会选择扩容来解决链表过长
## hashMap的resize的死循环问题
 + 1.7的时候时头插法， 在扩容的时候
1. new出来一个2倍大小的数组
2. 转移（transfer（）） 
3.两个线程同时走到transfer方法 ，两个线程里面都有next 和e ，多线程操作会导致 next和 e指针形成型链表
最终导致死循环
## ，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高
1. 容易碰撞， 空间浪费（详细解释如下）
+    看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ 
+ 所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。
